{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hi there \ud83d\udd96! \u00b6 My name is \ud83d\udc68Alejandro Piad Morffis. Here are some things about me: I live in Havana, \ud83c\udde8\ud83c\uddfaCuba, but I'm temporally located in Alicante, \ud83c\uddea\ud83c\uddf8Spain. I'm currently finishing a \ud83c\udf93PhD in Computer Science. In my free time, I also enjoy \ud83d\udcbb coding (mostly in \ud83d\udc0dPython), \ud83c\udfaeplaying video games (sadly not much lately), and \u270f\ufe0f writing . My two passions are \ud83d\udcdateaching and \u2697\ufe0fresearching. I teach Programming, Compilers, AI, and a bunch other stuff at the University of Havana. I also do research there, mostly on how to use artificial intelligence to better understand human languages. You can find me online on \ud83d\udde8\ufe0f Twitter , \ud83d\udcbc LinkedIn and \ud83d\ude1d Reddit . And these are the values I stand for: \u2764\ufe0f I believe that people are generally good, and if given the chance, they will show the better parts of themselves. \u2764\ufe0f I'm dedicated to education, because I think that access to high-quality, unbiased, and free education is one of the best gifts for anyone, and of the easiest ways to make people more reasonable and tolerant. \u2764\ufe0f I've been lucky to receive great education from a lot of awesome teachers, to whom I'll be forever grateful. For these reasons, I share what I know for free, in the hopes someone can find it useful. \u2764\ufe0f I also believe people should have the chance to speak their minds, without being afraid to being silenced, or hated for it, even if they are wrong. And they should have the option to recognize their mistakes, learn from them, and be forgiven. \u2764\ufe0f However, I do not tolerate racism or discrimination of any kind, and work very hard to apply those same standards to my own behavior.","title":"Home"},{"location":"#hi-there","text":"My name is \ud83d\udc68Alejandro Piad Morffis. Here are some things about me: I live in Havana, \ud83c\udde8\ud83c\uddfaCuba, but I'm temporally located in Alicante, \ud83c\uddea\ud83c\uddf8Spain. I'm currently finishing a \ud83c\udf93PhD in Computer Science. In my free time, I also enjoy \ud83d\udcbb coding (mostly in \ud83d\udc0dPython), \ud83c\udfaeplaying video games (sadly not much lately), and \u270f\ufe0f writing . My two passions are \ud83d\udcdateaching and \u2697\ufe0fresearching. I teach Programming, Compilers, AI, and a bunch other stuff at the University of Havana. I also do research there, mostly on how to use artificial intelligence to better understand human languages. You can find me online on \ud83d\udde8\ufe0f Twitter , \ud83d\udcbc LinkedIn and \ud83d\ude1d Reddit . And these are the values I stand for: \u2764\ufe0f I believe that people are generally good, and if given the chance, they will show the better parts of themselves. \u2764\ufe0f I'm dedicated to education, because I think that access to high-quality, unbiased, and free education is one of the best gifts for anyone, and of the easiest ways to make people more reasonable and tolerant. \u2764\ufe0f I've been lucky to receive great education from a lot of awesome teachers, to whom I'll be forever grateful. For these reasons, I share what I know for free, in the hopes someone can find it useful. \u2764\ufe0f I also believe people should have the chance to speak their minds, without being afraid to being silenced, or hated for it, even if they are wrong. And they should have the option to recognize their mistakes, learn from them, and be forgiven. \u2764\ufe0f However, I do not tolerate racism or discrimination of any kind, and work very hard to apply those same standards to my own behavior.","title":"Hi there \ud83d\udd96!"},{"location":"projects/","text":"Here are some of the most interesting projects I'm working on: Using the amazing github-readme-stats AutoGOAL \u00b6 AutoGOAL is a Python framework for Automated Machine Learning that I and a few other colleagues are building. It's the main research result of my wife's PhD , and it is a team project in which I'm a proud contributor and evangelist. Auditorium \u00b6 Auditorium is my attempt to bring together Python with HTML for interactive slideshows. It is based on reveal.js and allows creating a slideshow with pure Python code, including some interactive stuff like rendering graphs on the fly and running animations. Illiterate \u00b6 Illiterate is my take at the dilemma of code comments vs documentation. The idea stems from my love for the Literate Programming paradigm, but with a pragmatic twist that doesn't require any external tooling but rather relies on discipline and conventions.","title":"Projects"},{"location":"projects/#autogoal","text":"AutoGOAL is a Python framework for Automated Machine Learning that I and a few other colleagues are building. It's the main research result of my wife's PhD , and it is a team project in which I'm a proud contributor and evangelist.","title":"AutoGOAL"},{"location":"projects/#auditorium","text":"Auditorium is my attempt to bring together Python with HTML for interactive slideshows. It is based on reveal.js and allows creating a slideshow with pure Python code, including some interactive stuff like rendering graphs on the fly and running animations.","title":"Auditorium"},{"location":"projects/#illiterate","text":"Illiterate is my take at the dilemma of code comments vs documentation. The idea stems from my love for the Literate Programming paradigm, but with a pragmatic twist that doesn't require any external tooling but rather relies on discipline and conventions.","title":"Illiterate"},{"location":"essays/","text":"This is a collection of some things I've written over the years. Instead of blog posts, I consider them kind of short essays. They are varied in format and content, some are more technical, some are more philosophical. I don't really like to write tutorial-like articles. I think there are enough amazing people out there doing it much better than I. For the shortest, actionable stuff, I've currently started to tweetstorm . These are threads of 10-20 tweets that I'm also collecting here for future reference.","title":"Start here"},{"location":"essays/teaching/","text":"When people ask me who I am, the short answer is \"a teacher\", even though I do a bunch of other stuff. This is why. I didn't know I wanted to be a college teacher until about 3rd year of my major at University of Havana. Even then, the thought came slowly, something like \"yeah teaching could nice, but if I have to do something completely different, I may as well enjoy that\". By the end of 5th year (it was a 5 years major back then) I was sure there was nothing else that could fill me up. I've been in front of classroom for 9 years straight, at least twice a week one semester a year, ever since my first time. And I've loved every minute of it. Students are the same everywhere. They have hopes, dreams and a lot of misconceptions. They come thinking they want to be something (an engineer, a computer scientist, a journalist, a lawyer, ...), because they think that choice will lead them to do something (solve problems, work at a large company, travel the world, ...). So they focus in that search: what is the something they want to do, hence, the something they want to be? My main task is to try and convince them otherwise. The search is not about a something . It's about a someone . You need to come to college to discover who you want to be, not what you want to be. And if this sounds a bit philosophical (or plain crap), then I'm (un)apologetically sorry. Engineer, computer scientist, lawyer, all of those are just labels that somehow try to average over the set of things that people who label themselves that way like to do. Don't get me wrong, labels are important. They help us organize and understand the world. But if there is one occasion when you don't want a simple label to smooth away all the tiny details, is when choosing (or searching) what you want to do for life, or even better, who you want to be for life. So when people ask me \"are you an engineer, a scientist or a philosopher?\" I answer yes. I'm mostly a scientist, because I do more research than the average engineer; but I'm also an engineer, because I solve more problems than the average philosopher; and, I'm also a philosopher, because I like to think more about the implications of my decisions than the average scientist. I'm also a lot of other things, if you ask. It's not that I'm somehow \"better\" than any of these individual labels, it's simply that I choose to be my own personal brew of these \"things\", taking from each what I like and dumping what I don't. To a simple question ( what are you?) I can only give a simple answer (yes). If you want the details, you'll have to ask a deeper question: who are you? My first day in class every year, I like to throw a simple question at my students: who do you want to be? Most of them answer with a combination of whats. I want to be this or I want to do that. Over the course of the year, some of them actually start to discover they want to be someone , not just something. They start dumping the labels and start answering to this question not with things (I want to be a programmer) but with choices (I want to solve this specific problem, I want to cure this disease, I want to create this gadget). Those choices become the who they strive for. Eventually, even if unconsciously, most reach this state. A tiny fraction of them will consciously acknowledge it. And an even smaller fraction, maybe one or two a year, sometimes none, will actually come one day and say to me something like \"thank you for helping me find my who\", even if not with those exact words. And that's it. That small moment when I realize someone found its own best version, and I had a tiny bit of influence. That's my payment. That's why I love teaching.","title":"Why I love teaching"},{"location":"essays/team-playing/","text":"Modern higher education is all about competences and skills. In the process, we are losing some very bright people who just don't fit this narrow-minded model of professionalism. Modern education started with the Industrial Revolution and the need to graduate tons of skilled workers to carry on the same tasks over and over. Previously, education was only for the brightest and/or luckiest, and usually consisted of a very custom path through which a tutor would guide you. Nowadays in universities all around the world, we have reduced students to numbers, grades, percentages, as if we were producing computer chips or combustion engines. Efficiency is all that matters. In order to achieve the highest possible efficiency, all around the world we educators have become engineers of sorts. We designed what we call a \"model of the professional\", which is basically a set of skills and competences that an abstract ideal professional should have. Then we designed an evaluation metric which is basically the micro-average of a ton of super-narrow scores that measure super-specific skills such as taking a derivative or coding a recursive function. Finally, we designed a pipeline that takes students on one end and produces \"professionals\" on the other end. Those \"smart\" enough to learn to beat the system get the highest grades and are stamped with an abstract generic title of Computer Scientist, Medical Doctor, Lawyer, very much like a certificate of quality in a generic bottle of wine. This system is deeply flawed, and educators all over the world know it and have been discussing it for a long time. It's hard to change for many reasons, the least of which is the lack of teachers willing to dump the generic instruction set and craft custom learning paths for their students. I think this system is based on two basic assumptions, intuitive but flawed. Changing those assumptions could shed light on ways to improve the system. The first assumption is that students are a blank slate that when fed through this generic pipeline we call higher education will be magically morphed into this generic professional we designed. This is wrong for so many reasons that is hard to acknowledge it as a basic assumption of our system. Ask any university professor and they will all tell you the same: All students are different. They all have different skills, interests and biases. They all require a different approach to get the most out of them. And almost all of them, when given the chance and the right environment, will become the best versions of themselves. Yet time and time again we treat them as generic droids on which we can dump a generic course and expect a generic performance in return. The second assumption, I think, is harder to spot, because of the way the university is totally disconnected from real life all around the world. We educators think that society wants this \"model of the professional\", because we think that a hospital needs 100 equally generic doctors, and a software company needs 100 equally generic programmers. However, this is also wrong at some many levels. Everywhere we ask in the industry we keep hearing the same: we need unique people with unique skills that bring something new to the team. It's like trying to build an ensemble out of a 100 equal models. You get much better results with a variety of approaches to the same problem, than with an array of 100 exactly equal programs. Yet we keep translating what society asks into skills and competences. They tell us they need unique people, and we add \"uniqueness\" to the set of generic skills we want to teach with our generic college programs! So let's dump those two assumptions and acknowledge that we have a bunch of different kids with different interests and capabilities, and we need to turn them into a bunch of different professionals with different mindsets and skills. Now the question is how on earth can we do that? Again, we are basically engineers, we need to design a streamlined pipeline and a proper evaluation metric. And we need to do that, unfortunately, because there are so many more students than teachers that we cannot hope to be the Aristotle to each Alexander, and that's not about to change in the near future. I think one possible strategy is to focus on a single evaluation metric, and a single skill: Strive to transform every student into an effective team-player. Let's take it piece by piece. Every student is different, so everyone will have a different set of potential capabilities that could make them effective team-players. If we encourage those specific capabilities on each student, we are in fact giving each one a different learning path. This one will focus on improving her analytical skills, that one will focus on improving his management skills, that other one her social skills, and so on. Each one is focusing on her/his own most interesting, most desirable version of themselves. On the other hand, everyone is optimizing the same metric, being a good team-player, whatever the team. Give them back to society and they will fit in the right spot. The one spot that needs that specific mindset. Almost all low-hanging fruits that a single bright person could take are already taken, the problems that are left to solve as a society are the hard problems, and they all require teamwork. The easier problems are being automated away as I type. So, arguably, the best possible skill in the near future is being an effective team-player. If we strive to turn our students into exactly that, we are giving them the best education possible, and we are giving society the best possible return on that investment. The final question is how exactly do we do that? How do we discover what makes every student unique and valuable in a team? Isn't that the same Aristotle & Alexander dilemma? I think a possible solution is simply to let each of them discover it by themselves. As educators, instead of trying to tell everyone what to do, let's focus on designing learning environments that are comfortable for every student to explore her/his own skills and capabilities and decide the best way to serve the team. And let's evaluate them on co-op instead of solo, so that when trying to beat the system, they will actually optimize what we, the rest of the world, need them to be good at.","title":"It's all about team-playing"},{"location":"tweetstorms/","text":"These are short and actionable messages that I often post to Twitter. Not everything I write on Twitter is saved here, only those pieces of content that have enough value I think someone might be interested in bookmarking. If you want to read more thoughtful stuff, I also have some short essays where I take a longer time to explore more complex ideas.","title":"Start here"},{"location":"tweetstorms/theorythursday-algorithm-complexity/","text":"Algorithm Complexity \u00b6 You can see this tweetstorm as originally posted in this Twitter thread . Hey, guess what, today is #TheoryThursday \ud83e\uddd0! A silly excuse I just invented to share with you random bits of theory from some dark corner of Computer Science and make it as beginner-friendly as possible \ud83d\udc47 Today I want to talk about Algorithmic Complexity . To get started, take a look at the following code. How long do you think it will take to run it? Let's make that question more precise. How long do you think it will take to run it in the worst-case scenario? We can see that the code will run slower if: \ud83d\udc49 your computer is older; \ud83d\udc49 the array is longer; or \ud83d\udc49 x happens to be further to back, or not present at all. Can we turn these insights into an actual formula? We will have to get rid of ambiguous stuff like \"old computers\". 1\ufe0f\u20e3 First, let's consider an abstract computer in which all \"atomic\" operations take exactly 1 unit of time. \ud83e\udd14 Defining exactly what is an \"atomic\" operation is far from trivial. For now, assume it's things like arithmetic operations, indexing, invocation. 2\ufe0f\u20e3 Second, we'll count the number of operations with respect to the size of an arbitrary array. We will say something like \"this will cost 2 units of time for each element of the array\". 3\ufe0f\u20e3 Finally, we will consider the worst-case scenario. So we assume, in this example, that the element x is not in the array. More generally, we will always think about the maximum number of operations that could potentially happen. With these ideas in mind, we are ready to define the Algorithm Complexity of this algorithm. Let's count how many operations are performed in each step, assuming our array has length N: Depending on how detailed you want to be counting, you could say we have something like \ud83d\udd253*N+1\ud83d\udd25 operations in the ultimate worst-case scenario. \u2753 Now, why do we care about this? The reason is that we can now compare different algorithms. For example, if your implementation takes \ud83d\udd255*N+3\ud83d\udd25, then it is worse, right? Well, it's not \ud83d\ude1d Here's the deal: we have been assuming that all \"atomic\" operations are equally costly, but this is not true... Hence, it makes no sense to compare my implementation with your implementation by looking at those tiny differences. My 5 * N could be faster than your 3 * N if my \"atomic\" operations are simpler. \ud83d\udca1 We want a complexity measure that smooths away all implementation details. To achieve this, we will take away everything unimportant when N becomes very large. We will consider that: \ud83d\udc49 N+a and N+b are the same; \ud83d\udc49 a N and b N are the same; ... for any finite values a and b. \ud83d\udd11 And instead of saying 3*N+4, we will say the asymptotic algorithmic complexity is O(N). This is called big-O notation. \ud83d\udca1 We call this linear complexity because the number of operations grows linearly with respect to the size of the array. \ud83e\uddd0 Formally, it means that your function's cost is something that is bounded by a linear function. \ud83d\udca1 Intuitively, what this means is that in the long run, small differences like specific operations matter less than the capacity your algorithm has to scale with more data. The reason is simple, an algorithm with a lower asymptotic complexity will eventually win. Take for example binary search. https://en.wikipedia.org/wiki/Binary_search_algorithm It takes a bit of thinking, but we can prove the asymptotic notation to be O(log N). Binary search is doing much more work in each iteration than linear search. It could be 20 * log N vs 3 * N. Hence, with very small arrays, linear search could be better. \ud83d\udd11 But there is always a value of N after which binary search will win, and in any hardware. \u2764\ufe0f And that's it. We have just arrived at the intuitive notion of asymptotic complexity! Calculating it can be daunting for some non-trivial algorithms, but here are some tips for estimating it: 1\ufe0f\u20e3 Every nested for loop from beginning to end usually means another exponent. For example, two nested loops usually mean O(N^2), three nested loops, O(N^3), and four nested loops means you really need to take a break and, afterward, please refactor that code. 2\ufe0f\u20e3 An invocation to function F inside a loop means you have to multiply N times the complexity of F. For example, if we call binary search for each element of the array, the resulting algorithm is O(N log N) 3\ufe0f\u20e3 In recursive methods, if you split at the middle and recurse down only one branch, that's O(log N). If you recurse down both branches, you usually have O(N log N). These are special cases of a more general rule for recursive methods: https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms) Finally, we have just scratched the surface in this thread. Algorithmic complexity is a fascinating topic that touches all fields in Computer Science. The most important problem in all of CS comes from here, the infamous \ud83d\udd25P vs NP\ud83d\udd25. But that's a story for another Thursday \ud83d\ude09. \ud83d\udde8\ufe0f If you like this idea, then get into the conversation! Steal this #TheoryThursday hashtag an tell me about your favourite piece of dark magic. \ud83d\udd14 Just @ me and I'll make sure to weigh in. \ud83d\uddd2\ufe0f Here is the full thread source: https://apiad.net/tweetstorms/theorythursday-algorithm-complexity/","title":"Algorithm Complexity"},{"location":"tweetstorms/theorythursday-algorithm-complexity/#algorithm-complexity","text":"You can see this tweetstorm as originally posted in this Twitter thread . Hey, guess what, today is #TheoryThursday \ud83e\uddd0! A silly excuse I just invented to share with you random bits of theory from some dark corner of Computer Science and make it as beginner-friendly as possible \ud83d\udc47 Today I want to talk about Algorithmic Complexity . To get started, take a look at the following code. How long do you think it will take to run it? Let's make that question more precise. How long do you think it will take to run it in the worst-case scenario? We can see that the code will run slower if: \ud83d\udc49 your computer is older; \ud83d\udc49 the array is longer; or \ud83d\udc49 x happens to be further to back, or not present at all. Can we turn these insights into an actual formula? We will have to get rid of ambiguous stuff like \"old computers\". 1\ufe0f\u20e3 First, let's consider an abstract computer in which all \"atomic\" operations take exactly 1 unit of time. \ud83e\udd14 Defining exactly what is an \"atomic\" operation is far from trivial. For now, assume it's things like arithmetic operations, indexing, invocation. 2\ufe0f\u20e3 Second, we'll count the number of operations with respect to the size of an arbitrary array. We will say something like \"this will cost 2 units of time for each element of the array\". 3\ufe0f\u20e3 Finally, we will consider the worst-case scenario. So we assume, in this example, that the element x is not in the array. More generally, we will always think about the maximum number of operations that could potentially happen. With these ideas in mind, we are ready to define the Algorithm Complexity of this algorithm. Let's count how many operations are performed in each step, assuming our array has length N: Depending on how detailed you want to be counting, you could say we have something like \ud83d\udd253*N+1\ud83d\udd25 operations in the ultimate worst-case scenario. \u2753 Now, why do we care about this? The reason is that we can now compare different algorithms. For example, if your implementation takes \ud83d\udd255*N+3\ud83d\udd25, then it is worse, right? Well, it's not \ud83d\ude1d Here's the deal: we have been assuming that all \"atomic\" operations are equally costly, but this is not true... Hence, it makes no sense to compare my implementation with your implementation by looking at those tiny differences. My 5 * N could be faster than your 3 * N if my \"atomic\" operations are simpler. \ud83d\udca1 We want a complexity measure that smooths away all implementation details. To achieve this, we will take away everything unimportant when N becomes very large. We will consider that: \ud83d\udc49 N+a and N+b are the same; \ud83d\udc49 a N and b N are the same; ... for any finite values a and b. \ud83d\udd11 And instead of saying 3*N+4, we will say the asymptotic algorithmic complexity is O(N). This is called big-O notation. \ud83d\udca1 We call this linear complexity because the number of operations grows linearly with respect to the size of the array. \ud83e\uddd0 Formally, it means that your function's cost is something that is bounded by a linear function. \ud83d\udca1 Intuitively, what this means is that in the long run, small differences like specific operations matter less than the capacity your algorithm has to scale with more data. The reason is simple, an algorithm with a lower asymptotic complexity will eventually win. Take for example binary search. https://en.wikipedia.org/wiki/Binary_search_algorithm It takes a bit of thinking, but we can prove the asymptotic notation to be O(log N). Binary search is doing much more work in each iteration than linear search. It could be 20 * log N vs 3 * N. Hence, with very small arrays, linear search could be better. \ud83d\udd11 But there is always a value of N after which binary search will win, and in any hardware. \u2764\ufe0f And that's it. We have just arrived at the intuitive notion of asymptotic complexity! Calculating it can be daunting for some non-trivial algorithms, but here are some tips for estimating it: 1\ufe0f\u20e3 Every nested for loop from beginning to end usually means another exponent. For example, two nested loops usually mean O(N^2), three nested loops, O(N^3), and four nested loops means you really need to take a break and, afterward, please refactor that code. 2\ufe0f\u20e3 An invocation to function F inside a loop means you have to multiply N times the complexity of F. For example, if we call binary search for each element of the array, the resulting algorithm is O(N log N) 3\ufe0f\u20e3 In recursive methods, if you split at the middle and recurse down only one branch, that's O(log N). If you recurse down both branches, you usually have O(N log N). These are special cases of a more general rule for recursive methods: https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms) Finally, we have just scratched the surface in this thread. Algorithmic complexity is a fascinating topic that touches all fields in Computer Science. The most important problem in all of CS comes from here, the infamous \ud83d\udd25P vs NP\ud83d\udd25. But that's a story for another Thursday \ud83d\ude09. \ud83d\udde8\ufe0f If you like this idea, then get into the conversation! Steal this #TheoryThursday hashtag an tell me about your favourite piece of dark magic. \ud83d\udd14 Just @ me and I'll make sure to weigh in. \ud83d\uddd2\ufe0f Here is the full thread source: https://apiad.net/tweetstorms/theorythursday-algorithm-complexity/","title":"Algorithm Complexity"}]}